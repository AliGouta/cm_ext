// Licensed to Cloudera, Inc. under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  Cloudera, Inc. licenses this file
// to you under the Apache License, Version 2.0 (the
// "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
package com.cloudera.csd.validation.constraints.components;

import com.cloudera.csd.validation.constraints.MutuallyExclusiveType;
import com.cloudera.csd.validation.constraints.MutuallyExclusiveTypeValidator;
import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Sets;

import java.util.Collection;
import java.util.Set;

import javax.validation.ConstraintValidatorContext;

/**
 * A constraint validator to verify runtime class type given in
 * {@link MutuallyExclusiveType#types()} are exclusive of each other. This validator returns
 * a constraint violation if more than one type in the {@link MutuallyExclusiveType#types()}
 * is present in the validating {@link java.util.Collection}. They should be mutually exclusive.
 * <p>
 * Note, this validator doesn't treat duplicate objects of the same runtime class as
 * mutually exclusive of each other.
 */
public class MutuallyExclusiveTypeValidatorImpl implements MutuallyExclusiveTypeValidator {

  private Set<Class<?>> exclusivitySet;

  @Override
  public void initialize(MutuallyExclusiveType exclusive) {
    if (exclusive != null) {
      // Store it in a HashSet for O(1) lookups
      ImmutableSet.Builder<Class<?>> builder = ImmutableSet.builder();
      for (Class<?> type : exclusive.types()) {
        if (type != null) {
          builder.add(type);
        }
      }
      exclusivitySet = builder.build();
    }
  }

  @Override
  public boolean isValid(Collection<?> list, ConstraintValidatorContext context) {

    if (exclusivitySet == null) {
      // Initialization error, fail fast
      return false;
    }

    if (list == null) {
      return true;
    }

    Set<Class<?>> seenSoFar = Sets.newHashSet();
    for (Object obj : list) {
      Class<?> type = getTypeIfMatching(obj);
      if (type != null) {
        if (seenSoFar.size() > 0 && !seenSoFar.contains(type)) {
          // Found two distinct items in given collection. They are not mutually exclusive,
          // error.
          addViolation(context);
          return false;
        } else {
          seenSoFar.add(type);
        }
      }
    }

    return true;
  }

  /**
   * Find if the given object's first exclusive interface type matches any of the types
   * present in {@code exclusivitySet}.
   *
   * We check if two types match by doing a comparison directly on the runtime class type.
   * <p>
   * When CSDs are loaded, a runtime class (for example: class
   * org.codehaus.jackson.generated.com.cloudera.csd.descriptors.PlacementRuleDescriptor$AlwaysWithAnyRule)
   * for a descriptor is auto-created by Jackson, which implements the relevant descriptor
   * interfaces (for example:
   * interface com.cloudera.csd.descriptors.PlacementRuleDescriptor$AlwaysWithAnyRule).
   * <p>
   * Here, we simply can't perform {@code object.getClass()} to find underlying runtime class.
   * Because, the types in {@code exclusivitySet} would be of "interface" type and
   * will not match the ones generated by Jackson during runtime. Therefore, a direct
   * comparision of these two objects would fail. Instead, we get all the runtime interfaces
   * implemented by the object and check if the first exclusive interface type matches any of
   * the types present in {@code exclusivitySet}.
   *
   * @param obj the Object
   * @return Returns the runtime class type of the first interface that matches any of the
   * types present in {@code exclusivitySet}. If there is no match, a "null" is returned and
   * the caller should handle it appropriately.
   */
  private Class<?> getTypeIfMatching(Object obj) {
    if (obj != null) {
      Class<?> objClass = obj.getClass();
      if (objClass != null) {
        // Look for all the interfaces implemented by this class.
        for (Class<?> ref : objClass.getInterfaces()) {
          if (exclusivitySet.contains(ref)) {
            return ref;
          }
        }
      }
    }

    return null;
  }

  /**
   * Adds a violation in the context.
   *
   * @param context the context
   */
  @VisibleForTesting
  protected void addViolation(ConstraintValidatorContext context) {
    context.disableDefaultConstraintViolation();
    context.buildConstraintViolationWithTemplate(context.getDefaultConstraintMessageTemplate())
        .addConstraintViolation();
  }
}
